 * Better buffer performance:
   * if storing the text on a buffer is unusable, use the buffer as a proxy to scintilla.
   * Lock the buffer, you fool!
   * use mmap - have to create tmp files for unnamed buffers, and do clever stuff when assigning to filenames
   * it seems like dots were pathological when used with the python lexer.
   * Take care to not fiddle with the buffer while it is colorized
   * [DONE - routing the SyncFromBuffer through wx.CallAfter fixes this]
     running chatty 3 times with 100000 chars segfaults - memory leak
     somewhere? 
 * look into http://wiki.wxpython.org/LongRunningTasks for processes
 * [DONE] use multiple views (start with a split window with two STCs and blepoume) 
 * [DONE] editors should not bypass event handling when updating buffers - the buffers should not send events to the editors that created them
 * [DONE] More sophisticated buffer handling - synchronize 'actions' rather than text
 * [NOT STOOPID - IIAB, DFI] Um, would just sending the new line(s) back and forth be simpler than trying to synchronize a lot of crap?
 * [DONE] write the stdout to the console as well, for posterity
 * [DONE] use events rather than polling threads - editors subscribe to their buffers onchange events
 * [DONE] investigate prev/next buffer - each window should have its own index into the bufferlist - prev/next should take index arg
 * [DONE] list of buffers in menu - NB new buffers should automatically appear there
 * [DONE] create new windows (WindowManager.new)
 * kill buffers
 * save and load command line history
 * make the buffer look like a tty so that python shell can be run - pexpect/wexpect do that, have to
   add interaction layer on top
 * process manager
 * make new frames NB also when second instance started
 * add pluggable commands handler:
   - it should be possible to register : commands with their executor. function signature could be execute(command, context)
 * add pluggable keybindings handler
 * create a 'fundamental' STC with pluggable lexer 
   - candidates:
     - pyparsing - looks interesting but needs full compliance - possibly useful as second pass
     - plain re
     - re.Scanner
     - textmate syntax - complicated but powerful
     - vim syntax - looks grammar like, will check
     - http://www.gooli.org/snippets/pylexer.py - similar to re.Scanner
     - http://www.cosc.canterbury.ac.nz/greg.ewing/python/Plex/
     - http://nedbatchelder.com/text/python-parsers.html

